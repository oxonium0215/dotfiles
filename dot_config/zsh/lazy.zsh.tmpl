########################################
# 環境変数

# Additional paths not managed by mise
export PATH="$HOME/bin:/usr/local/bin:$PATH"
export PATH="$HOME/.local/share/bob/nvim-bin:$PATH"
export PATH="/snap/bin:$PATH"
export PATH="/usr/local/cuda/bin:$PATH"

# TinyTeX/TeXLive PATH configuration (auto-detect)
_setup_texlive_path() {
    # Skip if TeX is already available (package manager or already in PATH)
    command -v pdflatex >/dev/null 2>&1 && return

{{ if eq .chezmoi.os "darwin" -}}
    # macOS with MacTeX
    if [[ -d /Library/TeX/texbin ]]; then
        export PATH="/Library/TeX/texbin:$PATH"
        return
    fi
{{ end -}}

    # TinyTeX (mise-managed, user directory)
    local tinytex_base="$HOME/.TinyTeX"
    if [[ -d "$tinytex_base" ]]; then
        local bin_dir
        for bin_dir in "$tinytex_base/bin"/*; do
            if [[ -d "$bin_dir" && -x "$bin_dir/pdflatex" ]]; then
                export PATH="$bin_dir:$PATH"
                return
            fi
        done
    fi

    # Native TeXLive installation - find latest year
    local texlive_base="/usr/local/texlive"
    [[ ! -d "$texlive_base" ]] && return

    local year
    year=$(ls "$texlive_base" 2>/dev/null | grep -E '^[0-9]{4}$' | sort -rn | head -1)
    [[ -z "$year" ]] && return

    local bin_dir="$texlive_base/$year/bin"
    [[ ! -d "$bin_dir" ]] && return

    local arch
    arch=$(ls "$bin_dir" 2>/dev/null | head -1)
    [[ -z "$arch" ]] && return

    local full_path="$bin_dir/$arch"
    if [[ -x "$full_path/pdflatex" ]]; then
        export PATH="$full_path:$PATH"
        export MANPATH="$texlive_base/$year/texmf-dist/doc/man:${MANPATH:-}"
        export INFOPATH="$texlive_base/$year/texmf-dist/doc/info:${INFOPATH:-}"
    fi
}
_setup_texlive_path
unset -f _setup_texlive_path

export EDITOR=nvim
export SHELL=/bin/zsh
export MANPAGER='nvim +Man!'
export ZF_PROMPT=$(echo "\033[36mzf ❯ \033[m")

# sccache for Rust compilation (if available)
if command -v sccache >/dev/null 2>&1; then
    export RUSTC_WRAPPER=sccache
fi

# colorize less
export LESS_TERMCAP_mb=$'\e[1;32m'
export LESS_TERMCAP_md=$'\e[1;32m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;31m'

# LuaTeX Cache Environment Variables
export TEXMFCACHE="$HOME/.cache/texlive"
export TEXMFVAR="$HOME/.cache/texlive"
export LUAOTFLOAD_CACHE_DIR="$HOME/.cache/luatex/luaotfload"
export LUATEX_CACHE_DIR="$HOME/.cache/luatex"
export LUAOTFLOAD_NAMES_DIR="$HOME/.cache/luatex/luaotfload/names"

# Ensure cache directories exist on shell startup
if [[ ! -d "$LUAOTFLOAD_CACHE_DIR" ]]; then
    mkdir -p "$LUAOTFLOAD_CACHE_DIR/names"
    mkdir -p "$LUAOTFLOAD_CACHE_DIR/fonts"
    chmod -R 755 "$HOME/.cache/luatex"
fi

########################################
# alias
alias lst='eza -ltr --color=auto --icons'
alias l='eza -ltr --color=auto --icons'
alias ls='eza -a --icons'
alias la='eza -la --color=auto --icons'
alias ll='eza -l --color=auto --icons'
alias vi='nvim'
alias atc='atcoder-tools'
alias docker-purge='docker stop $(docker ps -q) && docker rmi $(docker images -q) -f'
# sudo の後のコマンドでエイリアスを有効にする
alias sudo='sudo '
# グローバルエイリアス
alias -g L='| less'
alias -g H='| head'
alias -g G='| grep'
alias -g GI='| grep -ri'

alias sudoe='sudo env PATH=$PATH'

########################################
# functions
zle-cd() {
    local dir=$(z | while IFS= read -r line; do echo ${line##* }; done | zf)
    if [ -z "$dir" ]; then
        zle reset-prompt
        return 0
    fi
    BUFFER="cd $dir"
    zle reset-prompt
    zle accept-line
}
zle -N zle-cd
bindkey '^j' zle-cd

# hooks
chpwd() {
    if [[ $(pwd) != $HOME ]]; then
        eza -a --group-directories-first
    fi
}

# どこからでも参照できるディレクトリパス
cdpath=(~)

# mise activation (env only, no hooks to keep 'cd' fast)
if command -v mise >/dev/null 2>&1; then
    eval "$(mise env -s zsh)"
else
    schedule_warning "%F{yellow}Warning: 'mise' is not installed. Tool version management is disabled.%f"
fi

# Check for 'zf' which is used in zle-cd
if ! command -v zf >/dev/null 2>&1; then
    schedule_warning "%F{yellow}Warning: 'zf' is not installed. 'Ctrl+j' (zle-cd) will not work.%f"
fi

########################################
# 補完
# 補完機能を有効にする
autoload -Uz compinit
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.m-1) ]]; then
    compinit -C
else
    compinit
fi
# 補完で小文字でも大文字にマッチさせる
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
# ../ の後で今いるディレクトリを補完しない
zstyle ':completion:*' ignore-parents parent pwd ..
# 補完の見た目を変更
zstyle ':completion:*' menu select
# sudo の後ろでコマンド名を補完する
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin \
    /usr/sbin /usr/bin /sbin /bin /usr/X11R6/bin
# ps コマンドのプロセス名補完
zstyle ':completion:*:processes' command 'ps x -o pid,s,args'

########################################
# git設定 (vcs_info) - async版
autoload -Uz vcs_info
autoload -Uz add-zsh-hook
setopt prompt_subst

zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:git:*' stagedstr "%F{yellow}!"
zstyle ':vcs_info:git:*' unstagedstr "%F{red}+"
zstyle ':vcs_info:*' formats "%F{green}%c%u[%b]%f"
zstyle ':vcs_info:*' actionformats "%F{red}%c%u[%b|%a]%f"

# Async vcs_info using zsh-async
_vcs_info_async_worker_name="vcs_info_worker"

# Callback function when async job completes
_vcs_info_async_callback() {
    local job=$1 code=$2 output=$3 exec_time=$4 stderr=$5
    
    # job is the function name, output is stdout
    if [[ $job == "_vcs_info_async_job" ]]; then
        RPROMPT="$output"
        zle && zle reset-prompt
    fi
}

# Async job function (runs in subshell)
_vcs_info_async_job() {
    cd -q "$1" 2>/dev/null || return
    vcs_info
    print -n "${vcs_info_msg_0_}"
}

# Start async worker
_vcs_info_async_init() {
    async_start_worker "$_vcs_info_async_worker_name" -n
    async_register_callback "$_vcs_info_async_worker_name" _vcs_info_async_callback
}

# Queue vcs_info job on precmd
_vcs_info_async_precmd() {
    async_flush_jobs "$_vcs_info_async_worker_name"
    async_job "$_vcs_info_async_worker_name" _vcs_info_async_job "$PWD"
}

# Initialize worker and register hook
_vcs_info_async_init
add-zsh-hook precmd _vcs_info_async_precmd

{{ if and (eq .chezmoi.os "linux") (contains "microsoft" (lower .chezmoi.kernel.osrelease)) -}}
########################################
# WSL: SSH Agent Forwarding for Bitwarden
if ! command -v socat >/dev/null 2>&1; then
    schedule_warning "%F{yellow}Warning: 'socat' is not installed. Bitwarden SSH Agent forwarding is disabled.%f"
elif ! command -v npiperelay.exe >/dev/null 2>&1; then
    schedule_warning "%F{yellow}Warning: 'npiperelay.exe' is not found in PATH. Bitwarden SSH Agent forwarding is disabled.%f"
else
    export SSH_AUTH_SOCK=/tmp/ssh-agent.sock

    # Start socat if socket doesn't exist or is dead
    if [[ ! -S "$SSH_AUTH_SOCK" ]]; then
        # Cleanup any potential stale processes just in case
        pkill -f "socat UNIX-LISTEN:$SSH_AUTH_SOCK" >/dev/null 2>&1
        rm -f "$SSH_AUTH_SOCK"
        
        NPIPERELAY_BIN=$(command -v npiperelay.exe)
        (setsid socat UNIX-LISTEN:"$SSH_AUTH_SOCK",fork,reuseaddr EXEC:"$NPIPERELAY_BIN -ei -s //./pipe/openssh-ssh-agent",nofork &) >/dev/null 2>&1

        # Wait for socket to be created
        local i
        for i in {1..10}; do
            [[ -S "$SSH_AUTH_SOCK" ]] && break
            sleep 0.05
        done
    fi

    # Async check for Bitwarden SSH Agent connection
    _bw_ssh_agent_check_callback() {
        local job=$1 code=$2 output=$3 exec_time=$4 stderr=$5
        
        if [[ $job == "_bw_ssh_agent_check_job" ]]; then
            # code 2 = agent not running, 124 = timeout (from our manual check)
            if [[ $output == "failed" ]]; then
                # Use the existing prompt injection mechanism to show the warning above the prompt
                schedule_warning "%F{red}Bitwarden SSH Agent connection failed. Fallback to standard SSH agent.%f"
                _zsh_inject_warnings
                if zle; then
                    zle reset-prompt
                fi
                unset SSH_AUTH_SOCK
            fi
        fi
    }
    
    _bw_ssh_agent_check_job() {
        timeout 1s ssh-add -l >/dev/null 2>&1
        local ret=$?
        if [[ $ret -eq 2 ]] || [[ $ret -eq 124 ]]; then
            print -n "failed"
        else
            print -n "ok"
        fi
    }
    
    # Run the check asynchronously
    async_start_worker "bw_ssh_check" -n
    async_register_callback "bw_ssh_check" _bw_ssh_agent_check_callback
    async_job "bw_ssh_check" _bw_ssh_agent_check_job
fi
{{ end -}}
